%% The following is a directive for TeXShop to indicate the main file
%%!TEX root = diss.tex

\chapter{Related Work}
\label{ch:RelatedWork}

In this chapter, we discuss the prior work which uses invariants to detect intrusion. We first classify the related work into categories based on the type of invariants generated and then discuss how the authors use the invariants generated for intrusion detection. Towards the end of this chapter a class of invariants, physical invariants, is discussed in detail which is of particular interest to us as we also generate physical invariants to anomaly detection.


We began by reviewing prior techniques for creating anomaly-based \ac{IDS} which were designed for a \ac{CPS}. Based on the models created, an \ac{IDS} was categorized into six main classes, a) \textit{data invariants}, which aims to use the values of data variables to generate the model; b) \textit{temporal invariants}, which uses the sequence of events in a given system to create the model; c) \textit{hardware invariants} use the hardware design of the system for which the \ac{IDS} needs to be designed as input to detect intrusion; d) \textit{network invariants}, work at the network level and analyze their activity to determine intrusion; e) \textit{cooperation invariants}, which are based on the interconnection between various components of the system to build a model; and f) \textit{physical invariants}, which uses the physical properties of the system to create a multi-dimensional model. The above mentioned invariants are discussed in detail below.

%\begin{enumerate}[label=(\alph*)]
\textbf{Data Invariants}: Significant work \cite{ernst2007daikon, csallner2008dysy, baliga2008automatic, baliga2011detecting, csallner2008dsd} has been done to determine how to extract data invariants from a system. Ernst et al. \cite{ernst2007daikon} built Daikon to dynamically mine data invariants of a system, thus creating pre- and post-conditions which hold at every entry and exit of a method/function.  Csallner et al. \cite{csallner2008dysy} propose DySy to extract data invariants by dynamically executing test cases and simultaneously performing symbolic execution of the program under study. In subsequent work, Csallner~\cite{csallner2008dsd} designed DSD-Crasher to determine a program's intended behavior for automatically generating test cases and finding bugs.
Baliga et al.~\cite{baliga2008automatic, baliga2011detecting} proposed Gibraltar, for inferring and enforcing data invariants to detect rootkits in the operating system's kernel.  

\textbf{Temporal Invariants}: Temporal invariants have been used to get a better understanding of a system, uncover bugs and to build \ac{IDS}. Yang et al.~\cite{yang2006perracotta}, define their model, Perracotta, to take as input a program and dynamically output temporal invariants. Gabel and Su~\cite{gabel2008javert} built Javert which is configured with two basic predefined patterns of temporal invariants. In subsequent work~\cite{gabel2010online} they built a tool OCD, which is capable of analyzing the trace continuously using a sliding window concept to generate invariants. Beschastnikh et al.~\cite{beschastnikh2011leveraging} generate temporal invariants dynamically through the use of system logs (traces) and programmer-specified regular expressions. Lemieux et al. \cite{lemieux2015general} dynamically generate all the instantiations of the invariants from a log file and the property types supplied in their tool called TEXADA. 

\textbf {Network Invariants}: Khurshid et al.\cite{khurshid2012veriflow} focus on maintaining network correctness and security using their tool, VeriFlow. They manually define network invariants like access control policies, absence of routing loops and availability of a path to the destination to monitor the network for any possible intrusion. Through this work, they aim to find faulty rules issued by SDN and prevent them from entering the network.

\textbf {Hardware Invariants}: Hangal et al.\cite{hangal2005iodine} build IODINE, a framework which dynamically infers invariants from hardware designs. They consume information called simulation dumps, which are generated by the hardware when the simulations occur. Then IODINE analyses simulation dumps using a series of analyzers to infer hardware invariants from it. They also employ some request-acknowledge patterns to extract invariants. They demonstrate their experience of using IODINE on the memory controller unit of a microprocessor. 

\textbf{Cooperation Invariants}: Waksman et al.\cite{waksman2010tamper} stress on building a trusted microprocessor from untrusted parts. They manually outline cooperation invariants which govern the intercommunication between several components of a microprocessor. They base their approach on the observation that execution of an instruction in microprocessor consists of several coupled events. Also, they assume that not all cooperating units are lying at the same time based on the real world operation. They develop TRUSTNET and DATAWATCH to maintain security, privacy and integrity of computer systems from malicious attacks.

\textbf{Physical Invariants}: Systems such as \ac{CPS} operate in the physical environment and conform to laws of physics. Therefore, they consist of physical properties which can be used to analyze the behavior of the system. Approaches from the prior work which use physical properties of the \ac{CPS}, to generate invariants can be classified into those that manually define physical invariants of the \ac{CPS}, and those that generate the invariants automatically from the \ac{CPS} behavior. The second approach is more useful than the first one, as it reduces the developer effort and time.

\begin{itemize}
\item \textbf{Manually defined physical invariants}: Mitchell and Chen ~\cite{mitchell2012specification} aim to secure an \ac{UAV} by specifying the physical invariants for each sensor and actuator embedded inside the system. In subsequent work, they designed an adaptive specification based \ac{IDS} \cite{mitchell2014adaptive} called BRUIDS, which could be adapted based on the attacker type and environment changes. Similarly, Choudhari et al. \cite{choudhari2013stability} manually describe scheduling invariants and physical invariants in the form of Lyapunov functions. Combining these invariants they produce cooperating invariants which specify and maintain the stability of the system. In another work, Paul et al. \cite{paul2014unified} represent a \ac{CPS} with one system invariant which encapsulates all of its subsystems. Adepu and Mathur \cite{adepu2016using} design an \ac{IDS} for a water treatment plant by manually describing the invariants for a particular sensor in terms of the water level changes between two consecutive readings.

\item \textbf{Automatically generated physical invariants}: Chen et al. \cite{chen2018learning} dynamically generate the physical invariant which is a \ac{SVM} model. This \ac{SVM} model is then used to classify an activity as benign or malicious for a real-world water purification plant. However, as they use statistical model checking, they only provide probabilistic guarantees that the system is correct, leaving room for \acf{FP} and \acf{FN}. Zohrevand et al. \cite{zohrevand2016hidden} dynamically generated the physical invariant which was a hidden semi-Markov model for a water supply system. Though they based their approach on  data collected from a real water supply system, their model was specialized for a specific \ac{CPS}. In recent work, Aliabadi et al. \cite{aliabadi2017artinali} designed ARTINALI, which dynamically mined data, time and event invariants from an execution trace of the program. They used the invariants in an \ac{IDS}, but did not consider physical properties other than time when generating the invariants. Krotofil et al. \cite{krotofil2015process} used correlations to identify anomalies in the \ac{TE} process challenge (a realistic simulation of a chemical process). They used the \acf{PCC} for deriving the cluster entropy, which is highly sensitive to outliers, and does not work well with non-linear data unlike \ac{HMM}. Also, they rely on physical placement of the sensors for the effectiveness of their approach. On the other hand, Iturbe et al. \cite{iturbe2017feasibility} use \ac{HMM} to distinguish between malicious attacks and natural disturbances for \ac{TE} process challenge using logical correlations. In contrast to our work, this research focuses more on diagnosing the reason behind the system's current state. 
\end{itemize}

\section{Summary}
There has been significant prior work to use invariants for intrusion detection. Unfortunately, the former class of systems incur high false-positives and false-negatives, thus implying unreliable detection. Physical invariants have the capacity to detect security attacks with low false positives and negatives, but current work either requires the invariants to be manually specified, which is time and effort intensive, or the systems have important gaps which inhibit their generalizability. In this research, an automated technique for capturing the logical correlations among physical variables in a generic \ac{CPS} is proposed, which uses such correlations for detecting intrusions.

\endinput
